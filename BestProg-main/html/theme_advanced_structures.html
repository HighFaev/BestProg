<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BestProger</title>
  <link rel="stylesheet" href="../css/stylies4.css">
</head>
<body>
<div class="site-header">
  <h1 class="glow-effect"><span>B</span><span>E</span><span>S</span><span>T</span><span>P</span><span>R</span><span>O</span><span>G</span><span>E</span><span>R</span></h1>
  <a href="../index.html" class="floating-button">Новости</a>
  <a href="thems.html" class="floating-button">Темы</a>
  <a href="taska.html" class="floating-button">Архив Задач</a>
</div>
<div class="main-site" >
  <div style="text-align: center"><h1 class="glow-effect"><span>П</span><span>р</span><span>о</span><span>д</span><span>в</span><span>и</span><span>н</span><span>у</span><span>т</span><span>ы</span><span>е</span><span> </span><span>с</span><span>т</span><span>р</span><span>у</span><span>к</span><span>т</span><span>у</span><span>р</span><span>ы</span><span>.</span><span> </span><span>С</span><span>т</span><span>е</span><span>к</span><span>,</span><span> </span><span>о</span><span>ч</span><span>е</span><span>р</span><span>е</span><span>д</span><span>ь</span><span>,</span><span> </span><span>д</span><span>е</span><span>к</span><span>.</span></h1></div>
</div>

<div class="wrap">
   <p style="font-size: 48px">Понятие структуры данных</p>
   <p>
     Чаще всего данные, с которыми работают программы, хранятся во встроенных в используемый язык программирования массивах, константной или переменной длины. Массив константной длины можно назвать простейшей структурой данных. Но иногда для решения задачи требуется большая эффективность некоторых операций, чем у массива. В таких случаях используются другие структуры данных, часто гораздо более сложные.

     <br><br>По определению, структура данных - способ представления данных в памяти, позволяющий эффективно выполнять с ними определённый набор операций. Например, простой массив лучше всего подходит для частого обращения к элементам по индексам и их изменению. А удаление элемента из середины массива работает за
     <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>O</mi>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
     </math>
     . Если вам для решения задачи нужно часто удалять элементы, то придётся воспользоваться другой структурой данной. Например, бинарное дерево (std::set) позволяет делать это за
     <math xmlns="http://www.w3.org/1998/Math/MathML">
       <mi>O</mi>
       <mo stretchy="false">(</mo>
       <mi>log</mi>
       <mo>&#x2061;<!-- ⁡ --></mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
     </math>
     , но не поддерживает работу с индексами, только поочерёдный обход всех элементов и поиск по значению (тоже за
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>log</mi>
        <mo>&#x2061;<!-- ⁡ --></mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
      </math>
      ).

      <br><br>Таким образом, структура данных характеризуется операциями, которые она может выполнять, и скоростью их выполнения.

      <br><br>В качестве примера рассмотрим несколько простейших структур данных, которые не предоставляют выгоды в эффективности, но имеют чётко определённый набор поддерживаемых операций.
      <p style="font-size: 48px">Понятие структуры данных</p>
      <p>
      Стек (англ. stack - стопка) - одна из простейших структур данных, представляющая собой скорее ограничение простого массива, чем его расширение. Классический стек поддерживает всего лишь три операции:
      <br><br>● Добавить элемент в стек (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
      <br>● Извлечь элемент из стека (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
      <br>● Проверить, пуст ли стек (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
            <mo stretchy="false">)</mo>
        </math>
        )
      <br><br>Для объяснения принципа работы стека часто используется аналогия со стаканом с печеньем. Представьте, что на дне вашего стакана лежат несколько кусков печенья. Вы можете положить наверх ещё один кусок или достать уже находящийся наверху. Остальные куски закрыты верхним, и вы про них ничего не знаете. Для описания стека часто используется аббревиатура LIFO (Last In, First Out), подчёркивающая, что элемент, попавший в стек последним, первым будет из него извлечён.
      <br><br>Приведём простую реализацию стека на C++. Для простоты максимальный размер нашего стека будет ограничен тысячей элементов:
      <div class="code-box">
          <pre>
<b>1.</b> struct stack {
<b>2.</b>     int a[1000];
<b>3.</b>     int head = -1;   //Индекс крайнего элемента.
<b>4.</b>
<b>5.</b>     void push(int x) {
<b>6.</b>         head++;
<b>7.</b>         a[head] = x;
<b>8.</b>     }
<b>9.</b>
<b>10.</b>    int pop() {
<b>11.</b>        if (head != -1) {
<b>12.</b>            head--;
<b>13.</b>            return a[head + 1];
<b>14.</b>        } else {
<b>15.</b>            //Ошибка, попытка извлечь элемент из пустого стека.
<b>16.</b>        }
<b>17.</b>    }
<b>18.</b>
<b>19.</b>    bool is_empty() {
<b>20.</b>        return head == -1;
<b>21.</b>    }
<b>22.</b>};
          </pre>
      </div>
    <p>
      Как видите, для реализации стека хватает одного массива и одного указателя, обозначающего крайний элемент.
      <p style="font-size: 48px">Очередь</p>
    <p>
      Очередь поддерживает тот же набор операций, что и стек, но имеет противоположную семантику. Для описания очереди используется аббревиатура FIFO (First In, First Out), так как первым из очереди извлекается элемент, раньше всех в неё добавленный. Название этой структуры говорит само за себя: принцип работы совпадает с обычными очередями в магазине или на почте.

      <br><br>Реализация очереди похожа на реализацию стека, но в этот раз нам понадобятся два указателя: для первого элемента очереди (“головы”) и последнего (“хвоста”):
  <div class="code-box">
          <pre>
<b>1.</b> struct queue {
<b>2.</b>     int a[1000];
<b>3.</b>
<b>4.</b>     //Для более лаконичной реализации работы, мы будем
<b>5.</b>     //хранить указатель не на последний элемент, а
<b>6.</b>     //на следующий за ним (несуществующий).
<b>7.</b>
<b>8.</b>     //Это, в частности, позволит нам проверять очередь на пустоту
<b>9.</b>     //простым условием head == tail
<b>10.</b>    int head = 0;    //Индекс первого элемента.
<b>11.</b>    int tail = 0;    //Индекс элемента, следующего за последним.
<b>12.</b>
<b>13.</b>    void push(int x) {
<b>14.</b>        a[tail] = x;
<b>15.</b>        tail++;
<b>16.</b>    }
<b>17.</b>
<b>18.</b>    int pop() {
<b>19.</b>        if (head != tail) {
<b>20.</b>            head++;
<b>21.</b>            return a[head - 1];
<b>22.</b>        } else {
<b>23.</b>            //Ошибка, попытка извлечь элемент из пустой очереди.
<b>24.</b>        }
<b>25.</b>    }
<b>26.</b>
<b>27.</b>    bool is_empty() {
<b>28.</b>        return head == tail;
<b>29.</b>    }
<b>30.</b>};
          </pre>
  </div>
    <p>
      При такой реализации очередь будет постепенно “ползти” вправо по выделенной области памяти (массиву), и достаточно быстро выйдет за её границы. Впрочем, эта реализация иллюстративная, на практике вы просто будете использовать уже готовую реализацию очереди из стандартной библиотеки (об этом ниже). В ней этот дефект отсутствует из-за более сложной работы с памятью.
      <p style="font-size: 48px">Дек</p>
      <p>
        Структура, объединяющая стек и очередь, называется дек (англ. deque - сокращение от double-ended queue, очередь с двумя концами). Как можно догадаться, она поддерживает уже знакомый набор операций:
        <br><br>● Добавить элемент в начало дека (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
        <br>● Извлечь элемент из начала дека (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
        <br>● Добавить элемент в конец дека (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
        <br>● Извлечь элемент из конца дека (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
        <br>● Проверить, пуст ли дек (Сложность:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mi>O</mi>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
        </math>
        )
        <br><br>В принципе мы можем реализовать её таким же способом, как и две предыдущих, но как и в случае с очередью, эта реализация будет далека от оптимальной.
        <div class="code-box">
          <pre>
<b>1.</b> struct deque {
<b>2.</b>     int a[2000];
<b>3.</b>
<b>4.</b>     //Используя такие начальные значения индексов, у нас
<b>5.</b>     //будет свободная память как слева, так и справа.
<b>6.</b>     int head = 1000;    //Индекс первого элемента.
<b>7.</b>     int tail = 1000;    //Индекс элемента, следующего за последним.
<b>8.</b>
<b>9.</b>     void push_front(int x) {
<b>10.</b>        head--;
<b>11.</b>        a[head] = x;
<b>12.</b>    }
<b>13.</b>
<b>14.</b>    void push_back(int x) {
<b>15.</b>        a[tail] = x;
<b>16.</b>        tail++;
<b>17.</b>    }
<b>18.</b>
<b>19.</b>    int pop_front() {
<b>20.</b>        if (head != tail) {
<b>21.</b>            head++;
<b>22.</b>            return a[head - 1];
<b>23.</b>        } else {
<b>24.</b>            //Ошибка, попытка извлечь элемент из пустого дека.
<b>25.</b>        }
<b>26.</b>    }
<b>27.</b>
<b>28.</b>    int pop_back() {
<b>29.</b>        if (head != tail) {
<b>30.</b>            tail--;
<b>31.</b>            return a[tail];
<b>32.</b>        } else {
<b>33.</b>            //Ошибка, попытка извлечь элемент из пустого дека.
<b>34.</b>        }
<b>35.</b>    }
<b>36.</b>
<b>37.</b>    bool is_empty() {
<b>38.</b>        return head == tail;
<b>39.</b>    }
<b>40.</b>};
          </pre>
        </div>
      <p>
        <p style="font-size: 48px">Стек, очередь и дек в стандартной библиотеке C++</p>
        <p>
          Все три структуры данных являются базовыми и относительно часто встречаются в програмировании, поэтому они уже реализованы в стандартной библиотеке в виде трёх шаблонных классов. Пример работы со стеком и очередью:
          <div class="code-box">
            <pre>
<b>1.</b> stack&lt;int> s;           //создание стека
<b>2.</b> s.push(5);              //добавление элемента
<b>3.</b> cout << s.top();        //обращение к верхнему элементу
<b>4.</b> if (!s.empty()) {       //проверка на пустоту
<b>5.</b>     s.pop();            //извлечение элемента (не возвращает значения,
<b>6.</b>                         //нужно предварительно использовать .top())
<b>7.</b> }
<b>8.</b>
<b>9.</b> queue&lt;int> q;                             //создание очереди
<b>10.</b>q.push(5);                                //добавление элемента
<b>11.</b>cout << q.front() << ' ' << q.back();     //обращение к первому и последнему элементам
<b>12.</b>if (!q.empty()) {                         //проверка на пустоту
<b>13.</b>    q.pop();                              //извлечение элемента (не возвращает значения,
<b>14.</b>                                          //нужно предварительно использовать .top())
<b>15.</b>}
            </pre>
          </div>
      <p>
        С реализацией дека дела обстоят несколько иначе. Стандартный класс std::deque является не классическим деком, а скорее вектором с возможностью вставки и добавления в начало за
        <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
        </math>
        . Он поддерживает все операции, поддерживаемые классом std::vector, в том числе обращение к элементу по индексу и итераторы с произвольным доступом. Так что для работы с ним используйте те же методы, что и при работе с вектором.
      <p style="font-size: 48px">Более сложные структуры данных</p>
      <p>
        Приведённый выше материал мог вызвать у вас лёгкое недоумение и сомнения в целесообразности всех этих ограничений на обычные массивы. На самом деле, стек, очередь и дек являются лишь простейшими примерами структур данных, не предоставляющими выгоды в скорости выполнения операций. Серьёзным структурам данных посвящены отдельные темы. Стек, очередь и дек призваны проиллюстрировать, что главными характеристиками структуры данных являются набор поддерживаемых операций и скорость их выполнения.
      </p>
</div>

<div class="site-footer">
  <a href="https://t.me/high_faev" class="double-border-button">My Telegram</a>
  <p class = "glow-effect-mini">
    <span><span>В</span><span>о</span><span>о</span><span>б</span><span>р</span><span>а</span><span>ж</span><span>а</span><span>е</span><span>м</span><span>о</span><span>е</span></span>
    <span><span>б</span><span>о</span><span>г</span><span>а</span><span>т</span><span>с</span><span>т</span><span>в</span><span>о</span></span> <span><span>з</span><span>н</span><span>а</span><span>н</span><span>и</span><span>я</span></span>
    <span>—</span> <span><span>г</span><span>л</span><span>а</span><span>в</span><span>н</span><span>а</span><span>я</span></span> <span><span>п</span><span>р</span><span>и</span><span>ч</span><span>и</span><span>н</span><span>а</span></span>
    <span><span>е</span><span>г</span><span>о</span></span> <span><span>б</span><span>е</span><span>д</span><span>н</span><span>о</span><span>с</span><span>т</span><span>и</span></span></p>
</div>
<script src="../jscode.js"></script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>