<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BestProger</title>
    <link rel="stylesheet" href="../css/stylies4.css">
</head>
<body>
<div class="site-header">
    <h1 class="glow-effect"><span>B</span><span>E</span><span>S</span><span>T</span><span>P</span><span>R</span><span>O</span><span>G</span><span>E</span><span>R</span></h1>
    <a href="../index.html" class="floating-button">Новости</a>
    <a href="thems.html" class="floating-button">Темы</a>
    <a href="taska.html" class="floating-button">Архив Задач</a>
</div>
<div class="main-site" >
    <div style="text-align: center"><h1 class="glow-effect"><span>П</span><span>о</span><span>н</span><span>я</span><span>т</span><span>и</span><span>е</span><span> </span><span>г</span><span>р</span><span>а</span><span>ф</span><span>о</span><span>в</span><span>,</span><span> </span><span>ц</span><span>и</span><span>к</span><span>л</span><span>о</span><span>в</span><span>,</span><span> </span><span>д</span><span>е</span><span>р</span><span>е</span><span>в</span><span>ь</span><span>е</span><span>в</span></h1></div>
</div>

<div class="wrap">
    <p style="font-size: 48px">Определение графа</p>
    <p>
        Графы - фундаментальное понятие как в математике, так и в информатике. Проще всего объяснить его с помощью аналогии с дорожной системой. Существует определённый набор городов, некоторые из которых связаны дорогами, которые могут быть как односторонними, так и двухсторонними. Вся эта структура и называется графом.

        <br><br>Ну а более формально, граф - комбинация набора вершин и набора рёбер. Вершины - это города, а рёбра - дороги. Визуально граф можно представить так:
        <br><img src="../img/6n-graf.png" alt="ОЙ ой"><br>
        Этот граф состоит из 6 вершин, пронумерованных начиная с единицы, и 7 двухсторонних рёбер. Рёбра обычно записывают в виде пар вершин, которые они соединяют: <b>1-2, 1-5, 2-3, 2-5, 3-4, 4-5, 4-6</b>.

    <br><p style="font-size: 48px">Ориентированные и неориентированные графы</p>
    <p>
        <br>Мы уже упоминали, что “дороги” в графе могут быть как односторонними, так и двухсторонними. Для этого свойства существует отдельный термин: односторонние “дороги” называются ориентированными рёбрами (или дугами), а двухсторонние - неориентированными.

        <br><br>Граф, в котором все рёбра неориентированные, также называют неориентированным, а граф с ориентированными рёбрами, соответственно, ориентированным.

        <br>
        <img src="../img/Undirected.png" alt="Ой ой">
        <img src="../img/Directed.png" alt="Ой ой">
        <br>Слева изображён неориентированный граф, а справа - ориентированный. Как несложно догадаться, левый граф можно обходить как по часовой стрелке, так и против, а правый можно полностью обойти только по часовой, хотя одно из ребёр в нём также неориентированное (считается, что это два противоположных ориентированных ребра).

    <br><p style="font-size: 48px">Пути и циклы</p>
    <p>
        <br>Путём в графе называется последовательность вершин, каждая из которых соединена со следующей ребром. Чаще всего под “путём” подразумевают простой путь, все вершины которого различны. Путь, который проходит через какую-либо вершину более одного раза называют сложным путём.

        <br><br>Если первая вершина пути совпадает с последней, то такой путь называют циклом.

        <br><br>Приведём примеры на этом графе:
        <br><img src="../img/Cyclic-graph.png" alt="Ой ой">
        <br>Из множества возможных простых путей самый длинный:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>a</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>f</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>c</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>d</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>e</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>b</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>h</mi>
        </math>
        (существуют и другие пути с такой же длиной).

        <br><br>Циклом является путь
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>b</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>c</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>d</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>e</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>b</mi>
        </math>
        (выделен цветом). Можно начать и с любой другой вершины, например,
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>c</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>d</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>e</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>b</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>c</mi>
        </math>
        .

    <br><p style="font-size: 48px">Кратные рёбра и петли</p>
    <p>
        <br>Существует множество разновидностей графов, и среди них встречаются довольно специфические. В частности, так называемые мультиграфы разрешают наличие между двумя вершинами нескольких рёбер (называемых кратными рёбрами), а также наличие петель. Петля - ребро, входящее в ту же вершину, из которой исходит. Выглядят они следующим образом:
        <br><img src="../img/Multi-pseudograph.png" alt="Ой ой">
        <br><br>Красным выделены кратные рёбра, а синим - петли.

        <br><br>Мультиграфы встречаются в задачах реже чем обычные графы (называемые простыми), но всё же встречаются, поэтому стоит иметь о них элементарное представление.

    <br><p style="font-size: 48px">Связные графы</p>
    <p>
        <br>Граф называется связным если между любой парой вершин существует хотя бы один путь. Как пример рассмотрим следующий граф:
        <br><img src="../img/Sample-graph.jpg" alt="Ой ой">
        <br>Одно из рёбер проведено штрихами. Если это ребро присутствует, то граф является связным. Если же его убрать, то связность теряется, граф разбивается на две части, друг с другом не связанные. Такие части называются компонентами связности.

    <br><p style="font-size: 48px">Определение дерева</p>
    <p>
        <br>Дерево - вид графа, который можно назвать самым простым, но они обладают множеством особых свойств и встречаются в задачах чуть ли не чаще остальных графов.
        <br><br><b>Дерево - это связный граф без циклов, петель и кратных рёбер.</b>
        <br><br>Все изображённые графы являются деревьями:
        <br><br><img src="../img/Tree2.png" width="800" height="600" alt="Ой ой" >
        <br><img src="../img/Tree4.png" width="700" height="400" alt="Ой ой">
        <br><img src="../img/Tree3.png" width="800" height="500" alt="Ой ой">
        <br>Среди множества свойств деревьев можно выделить два самых известных:

        <br><br><b>1.</b> Количество рёбер связано с количеством вершин формулой
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>E</mi>
            <mo>=</mo>
            <mi>V</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mn>1</mn>
        </math>
        .
        <br><b>2.</b>Между любой парой вершин существует ровно один путь.

    <br><p style="font-size: 48px">Матрица смежности</p>
    <p>
        <br>Существует два основных способа представления графов в программировании. Один из них, матрица смежности, используется гораздо реже, но очень просто реализуется. Граф из
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>N</mi>
        </math>
        вершин задаётся матрицей (двумерным массивом)
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>N</mi>
            <mo>&#x2217;<!-- ∗ --></mo>
            <mi>N</mi>
        </math>
        , в которой
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>g</mi>
            <mo stretchy="false">[</mo>
            <mi>i</mi>
            <mo stretchy="false">]</mo>
            <mo stretchy="false">[</mo>
            <mi>j</mi>
            <mo stretchy="false">]</mo>
        </math>
        - логическое значение, true или false, обозначающее, существует ли ребро из вершины
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>i</mi>
        </math>
        в вершину
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>j</mi>
        </math>
        .

        <br><br>В качестве примера решим простую задачу: для каждой вершины графа выведем количество рёбер, смежных с ней.

    <div class="code-box">
        <pre>
            <br>
<b>1.</b> using namespace std;
<b>2.</b>
<b>3.</b> bool graph[1000][1000];
<b>4.</b>
<b>5.</b> int main() {
<b>6.</b>     int n, m;       //количество вершин и рёбер соответственно
<b>7.</b>     cin >> n >> m;
<b>8.</b>
<b>9.</b>     for (int i = 0; i < m; i++) {
<b>10.</b>        int u, v;   //номера вершин, соединённых очередным ребром
<b>11.</b>        cin >> u >> v;
<b>12.</b>
<b>13.</b>        u--, v--;   //Здесь стоит остановиться и вдуматься.
<b>14.</b>                    //Чаще всего в задачах вершины будут нумероваться с 1 до N,
<b>15.</b>                    //в отличие от индексации массивов в C++.
<b>16.</b>
<b>17.</b>                    //У этой проблемы есть два решения.
<b>18.</b>                    //Первое: работать с номерами "как есть": создавать массивы размером N + 1,
<b>19.</b>                    //использовать циклы от 1 до N, и т.д.
<b>20.</b>                    //Второе: уменьшать номера вершин на единицу при вводе, и увеличивать обратно при выводе
<b>21.</b>
<b>22.</b>                    //Какое из них использовать - ваш личный выбор.
<b>23.</b>                    //Для меня 1-индексация в С++ выглядит очень чужеродно, поэтому я использую второе решение.
<b>24.</b>
<b>25.</b>        graph[u][v] = graph[v][u] = true;   //Если бы граф был ориентированным, то обратное ребро мы бы не создавали.
<b>26.</b>    }
<b>27.</b>
<b>28.</b>    for (int i = 0; i < n; i++) {
<b>29.</b>        int c = 0;
<b>30.</b>        for (int j = 0; j < n; j++) {
<b>31.</b>            if (graph[i][j]) {
<b>32.</b>                c++;
<b>33.</b>            }
<b>34.</b>        }
<b>35.</b>
<b>36.</b>        cout << c << " edges adjacent to vertex " << i + 1 << endl;
<b>37.</b>    }
<b>38.</b>}
        </pre>
    </div>
    <p>
        Если требуется также удалять рёбра, то вместо вектора нужно использовать std::set.
        <br><br><b>Преимущества матрицы смежности:</b>

        <br><br><b>1.</b>Сложность проверки наличия ребра между двумя вершинами:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>O</mi>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
        </math>

        <br><br><b>Недостатки матрицы смежности:</b>

        <br><br><b>1.</b>Занимает
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
                <mi>N</mi>
                <mn>2</mn>
            </msup>
        </math>
        памяти, что неприемлемо для достаточно больших графов.
        <br><b>2.</b>ложность перебора всех вершин, смежных с данной:
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>O</mi>
            <mo stretchy="false">(</mo>
            <mi>N</mi>
            <mo stretchy="false">)</mo>
        </math>

    <br><p style="font-size: 48px">Список смежности</p>
    <p>
        Гораздо чаще для представления графов используется список смежности. Его идея заключается в хранении для каждой вершины расширяемого массива (вектора), содержащего всех её соседей.

        <br>Решим ту же задачу с использованием списка смежности (и С++11 для for-each):
        <div class="code-box">
            <pre>
<b>1.</b>using namespace std;
<b>2.</b>
<b>3.</b>vector&lt;int> graph[100000];    //массив из 100000 векторов.
<b>4.</b>
<b>5.</b>int main() {
<b>6.</b>    int n, m;
<b>7.</b>    cin >> n >> m;
<b>8.</b>
<b>9.</b>    for (int i = 0; i < m; i++) {
<b>10.</b>        int u, v;
<b>11.</b>        cin >> u >> v;
<b>12.</b>        u--, v--;
<b>13.</b>
<b>14.</b>        graph[u].push_back(v);
<b>15.</b>        graph[v].push_back(u);
<b>16.</b>    }
<b>17.</b>
<b>18.</b>    for (int i = 0; i < n; i++) {
<b>19.</b>        int c = 0;
<b>20.</b>        for (int v: graph[i]) {     //можно было бы просто записать "int c = graph[i].size();",
<b>21.</b>            c++;                    //но такая реализация показывает, как можно перебирать
<b>22.</b>        }                           //соседние вершины.
<b>23.</b>
<b>24.</b>        cout << c << " edges adjacent to vertex " << i + 1 << endl;
<b>25.</b>    }
<b>26.</b>}
            </pre>
        </div>
    <p>
        Если требуется также удалять рёбра, то вместо вектора нужно использовать std::set.
        <br><br><b>Преимущества списка смежности</b>:
        <br><br><b>1.</b>Использует
        <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>O</mi>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
        </math> памяти, что оптимально
        <br><b>2.</b>Позволяет быстро перебирать соседей вершины.
        <br><b>3.</b>Позволяет за
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>O</mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>&#x2061;<!-- ⁡ --></mo>
            <mi>N</mi>
            <mo stretchy="false">)</mo>
        </math>
        проверять наличие ребра и удалять его (при использовании std::set).
        <br><br><b>Недостатки списка смежности</b>:
        <br><br><b>1.</b>При работе с насыщенными графами (количество рёбер близко к
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <msup>
                <mi>N</mi>
                <mn>2</mn>
            </msup>
        </math>
        ) скорости
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>O</mi>
            <mo stretchy="false">(</mo>
            <mi>log</mi>
            <mo>&#x2061;<!-- ⁡ --></mo>
            <mi>N</mi>
            <mo stretchy="false">)</mo>
        </math>
        может не хватать (единственный повод использовать матрицу смежности).
        <br><b>2.</b>Для взвешенных графов приходится хранить vector&lt;pair&lt;int, int>>, что усложняет код.
    </p>
</div>

<div class="site-footer">
    <a href="https://t.me/high_faev" class="double-border-button">My Telegram</a>
    <p class = "glow-effect-mini">
        <span><span>В</span><span>о</span><span>о</span><span>б</span><span>р</span><span>а</span><span>ж</span><span>а</span><span>е</span><span>м</span><span>о</span><span>е</span></span>
        <span><span>б</span><span>о</span><span>г</span><span>а</span><span>т</span><span>с</span><span>т</span><span>в</span><span>о</span></span> <span><span>з</span><span>н</span><span>а</span><span>н</span><span>и</span><span>я</span></span>
        <span>—</span> <span><span>г</span><span>л</span><span>а</span><span>в</span><span>н</span><span>а</span><span>я</span></span> <span><span>п</span><span>р</span><span>и</span><span>ч</span><span>и</span><span>н</span><span>а</span></span>
        <span><span>е</span><span>г</span><span>о</span></span> <span><span>б</span><span>е</span><span>д</span><span>н</span><span>о</span><span>с</span><span>т</span><span>и</span></span></p>
</div>

<script src="../jscode.js"></script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>