<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BestProger</title>
    <link rel="stylesheet" href="../css/stylies4.css">
</head>
<body>
<div class="site-header">
    <h1 class="glow-effect">
        <span>B</span><span>E</span><span>S</span><span>T</span><span>P</span><span>R</span><span>O</span><span>G</span><span>E</span><span>R</span>
    </h1>
    <a href="../index.html" class="floating-button">Новости</a>
    <a href="thems.html" class="floating-button">Темы</a>
    <a href="taska.html" class="floating-button">Архив Задач</a>
</div>
<div class="main-site">
    <div style="text-align: center"><h1 class="glow-effect">
        <span>D</span><span>F</span><span>S</span><span>,</span><span> </span><span>B</span><span>F</span><span>S</span><span> </span><span>к</span><span>а</span><span>к</span><span> </span><span>п</span><span>р</span><span>и</span><span>м</span><span>е</span><span>р</span><span>ы</span><span> </span><span>р</span><span>е</span><span>к</span><span>у</span><span>р</span><span>с</span><span>и</span><span>и</span>
    </h1></div>
</div>

<div class="wrap">
    <p style="font-size: 48px">Краткое введение в рекурсию</p>
    <p>
        Возможно, вам уже когда-либо приходилось сталкиваться с рекурсией. Рекурсия - фундаментальное понятие в
        информатике, в каком-то смысле настолько же важное, как и циклы.

        <br><br>По определению, рекурсивная функция - функция, которая вызывает сама себя. В математической терминологии
        рекурсивная функция определяется через саму себя. Существует множество известных примеров рекурсивных функций,
        приведём две самых известных:
        <br><br>● Факториал. По определению, факториал от числа N - произведение всех чисел от 1 до N. Рекурсивно это
        записывается так:
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mn>1</mn>
            <mo>!</mo>
            <mo>=</mo>
            <mn>1</mn>
            <mspace linebreak="newline"/>
            <mi>N</mi>
            <mo>!</mo>
            <mo>=</mo>
            <mo stretchy="false">(</mo>
            <mi>N</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
            <mo>!</mo>
            <mo>&#x2217;<!-- ∗ --></mo>
            <mi>N</mi>
        </math>
        Первая формула - крайний случай, определяющий факториал от единицы. Вторая формула - общий случай, определяющий
        факториал от любого натурального числа через факториал от предыдущего числа.
        <br><br>●Последовательность чисел Фибоначчи. По определению каждое число этой последовательности - сумма двух
        предыдущих. Два первых числа в разных источниках определяются по разному: это могут быть 0 и 1, или 1 и 1. Мы
        будем придерживаться второго варианта:
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
                <mi>F</mi>
                <mn>1</mn>
            </msub>
            <mo>=</mo>
            <msub>
                <mi>F</mi>
                <mn>2</mn>
            </msub>
            <mo>=</mo>
            <mn>1</mn>
            <mspace linebreak="newline"/>
            <msub>
                <mi>F</mi>
                <mi>n</mi>
            </msub>
            <mo>=</mo>
            <msub>
                <mi>F</mi>
                <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mo>&#x2212;<!-- − --></mo>
                    <mn>1</mn>
                </mrow>
            </msub>
            <mo>+</mo>
            <msub>
                <mi>F</mi>
                <mrow class="MJX-TeXAtom-ORD">
                    <mi>n</mi>
                    <mo>&#x2212;<!-- − --></mo>
                    <mn>2</mn>
                </mrow>
            </msub>
        </math>
        И опять у нас две формулы: для крайнего случая и для общего.
        <br><br>В программировании это записывается так же прозрачно:
    <div class="code-box">
      <pre>
<b>1.</b> int fact(int x) {
<b>2.</b>     if (x == 1) {
<b>3.</b>         return 1;
<b>4.</b>     } else {
<b>5.</b>         return fact(x - 1) * x;
<b>6.</b>     }
<b>7.</b> }
<b>8.</b>
<b>9.</b> int fib(int n) {
<b>10.</b>    if (n <= 2) {
<b>11.</b>        return 1;
<b>12.</b>    } else {
<b>13.</b>        return fib(n - 1) + fib(n - 2);
<b>14.</b>    }
<b>15.</b>}
      </pre>
    </div>
    <p>
        (Примечание: хотя числа Фибоначчи - хороший пример рекурсии в математике, в программировании приведённую выше
        рекурсивную реализацию ни в коем случае нельзя использовать на практике. Её сложность равна порядка
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <mi>O</mi>
            <mo stretchy="false">(</mo>
            <msup>
                <mn>2</mn>
                <mi>n</mi>
            </msup>
            <mo stretchy="false">)</mo>
        </math>
        , что, разумеется, неприемлемо. Более подробно это будет разобрано в лекции про динамическое программирование.)

        <br><br>Существует мнение, что лучший способ понять рекурсию - это <a href="../img/recursion_meme.jpg"
                                                                              style="text-decoration: line-through">понять
        рекурси<a href="../img/image_2021-06-10_10-59-12.png" style="text-decoration: line-through">ю</a></a> работа с целесообразными рекурсивными алгоритмами. Поэтому не будем углубляться в детали, а сразу
        перейдём к поиску в глубину.
    <p style="font-size: 48px">Принцип работы обхода в глубину</p>
    <p>
        Обход в глубину, или DFS (англ. depth-first search), в чём-то похож на действия, выполняемые человеком для
        прохождения лабиринта (DFS собственно и является алгоритмом для решения лабиринтов). Находясь на очередной
        развилке, мы ставим метку, обозначающую, что мы уже здесь были, после чего идём в произвольном ещё не посещённом
        направлении. На следующей развилке мы выполняем те же действия, и так пока не попадём на развилку, которая не
        открывает нам ни одного нового пути (все уже посещены). В таком случае мы возвращаемся на предыдущую развилку и,
        если там ещё остались непосещённые направления, идём туда. Если же оттуда также некуда идти, то мы возвращаемся
        назад ещё на одну развилку, и так далее, пока не найдём непосещённое направление.
        <br><br>Иллюстрация прохождения лабиринта с помощью DFS:
        <img src="../img/dfs_maze.gif" alt="Ой ой">
        <br><br>Неочевидным моментом может быть выбор конкретного непосещённого направления из нескольких возможных на
        очередной развилке. DFS никак этого не определяет. Можно, например, всегда стараться идти вправо вниз, или
        наоборот, влево вверх, или вообще выбирать случайное направление. На суть алгоритма это никак не влияет. <b>DFS
        выбирает случайный путь, тогда как BFS ищет кратчайший</b>.
        <br><br>В принципе, точно описать алгоритм можно всего лишь одной функцией со следующим псевдокодом:
    <div class="code-box">
        <pre>
 dfs(v):
   visited[v] = true
   ...обработка вершины v
   for v -> u:
       if not visited[u]:
           dfs(u)
        </pre>
    </div>
    <p>
        Иллюстрация обхода графа (дерева) с помощью DFS:
        <br><img src="../img/dfs.gif" alt="Ой ой">
    <p style="font-size: 30px">Реализация для произвольного графа</p>
    <p>
        Для представления графа используется список смежности:
    <div class="code-box">
            <pre>
<b>1.</b> #include &lt;bits/stdc++.h>
<b>2.</b>
<b>3.</b> using namespace std;
<b>4.</b>
<b>5.</b> vector&lt;int> graph[100000];
<b>6.</b> bool used[100000];      //вместо visited массив меток обычно называют used.
<b>7.</b>
<b>8.</b> void dfs(int v) {
<b>9.</b>     used[v] = true;
<b>10.</b>    cout << "DFS at vertex " << v + 1 << endl;
<b>11.</b>
<b>12.</b>    for (int u: graph[v]) {
<b>13.</b>        if (!used[u]) {
<b>14.</b>            dfs(u);
<b>15.</b>        }
<b>16.</b>    }
<b>17.</b>}
<b>18.</b>
<b>19.</b>int main() {
<b>20.</b>    //Ввод графа...
<b>21.</b>
<b>22.</b>    dfs(0);     //Начинаем обход с вершины 0.
<b>23.</b>}
            </pre>
    </div>
    <p>
        Как видите, код получился очень лаконичным: функция DFS уложилась в 10 строк.
    <p style="font-size: 30px">Реализация для дерева</p>
    <p>
        Очень часто DFS применяется не для произвольного графа, а для дерева. Это позволяет реализовать алгоритм немного
        по другому: засчёт отсутствия в дереве циклов мы можем избавиться от массива used. Достаточно всего лишь
        передавать в функцию ещё один параметр: предыдущую вершину. Этот параметр необходим, чтобы не попасть в
        бесконечный цикл из двух вершин (постоянно проходя по одному и тому же ребру).
        <br><br>Реализация:
    <div class="code-box">
          <pre>
<b>1.</b>#include &lt;bits/stdc++.h>
<b>2.</b>
<b>3.</b>using namespace std;
<b>4.</b>
<b>5.</b>vector&lt;int> graph[100000];    //храним дерево как и обычный граф
<b>6.</b>
<b>7.</b>void dfs(int v, int p = -1) {   //p (от parent) - предыдущая вершина, для начальной вершины равна -1.
<b>8.</b>    cout << "DFS at vertex " << v + 1 << endl;
<b>9.</b>
<b>10.</b>    for (int u: graph[v]) {
<b>11.</b>        if (u != p) {
<b>12.</b>            dfs(u, v);
<b>13.</b>        }
<b>14.</b>    }
<b>15.</b>}
<b>16.</b>
<b>17.</b>int main() {
<b>18.</b>    //Ввод графа...
<b>19.</b>
<b>20.</b>    dfs(0);     //Начинаем обход с вершины 0.
<b>21.</b>}
          </pre>
    </div>
    <p>
        С обходом деревьев связана некоторая дополнительная терминология. Вершину, с которой начинается обход называют
        <b>корнем</b>. Иногда в задачах корень дерева явно обозначен, а иногда его нужно выбирать самостоятельно (чаще
        всего эту роль выполняет первая вершина). Начав обход дерева с другой вершины (другого корня), мы получим другой
        порядок обхода вершин. Для обозначения такого действия есть свой термин: <b>подвешивание</b> дерева за
        определённую вершину.
        <br><img src="../img/tree_roots.png" style="position: relative; left: 50vh" alt="Ой ой">
        <br>Изображено одно и то же дерево, подвешенное за разные вершины: 1 и 2 соответственно. Чаще всего деревья
        изображаются в таком виде: корень сверху, все остальные вершины вертикально разделены по уровням. Считается, что
        BFS “спускается” по дереву сверху вниз.
        <br><br>Все вершины, в которые мы можем попасть из определённой вершины, спускаясь “вниз” с помощью DFS,
        называются её <b>поддеревом</b>. Вершины, из которых мы больше не можем никуда “спуститься” называются <b>листьями</b>.
        <img src="../img/subtree.png" style="position: relative; left: 75vh" alt="Ой ой">
        <br>На иллюстрации зелёным цветом закрашены листья дерева, а красным - поддерево вершины 2 (листья тоже в него
        входят).

    <p style="font-size: 30px">Применение DFS</p>
    <p>
        Главное преимущество DFS перед BFS - простота реализации. На это влияет как малый размер необходимого кода, так
        и рекурсивный подход вместо итеративного (со временем вы начнёте воспринимать рекурсию гораздо более натурально,
        чем циклы и структуры данных). На реализацию DFS с опытом уходит менее 10 секунд.

        <br><br>Что касается выполнимых задач, стоит чётко уяснить один факт: <b>DFS не может находить кратчайшие
        пути</b>. Как бы вы не пытались его модифицировать, это невозможно по определению. В остальном область
        применения DFS в основном совпадает с таковой у BFS, и выбор одного из алгоритмов - личное дело каждого.

        <br><br>На практике DFS чаще всего используют для проверка графа на связность, или более обобщённо, поиска
        компонент связности, поиска циклов и работы с деревьями.

    <p style="font-size: 48px">Обход в ширину (BFS)</p>
    <p style="font-size: 30px">Определение</p>
    <p>
        <br>Под обходом понимается последовательное посещение (обработка) вершин графа в определённом порядке. Одним из
        двух часто использующихся способов обхода является обход в ширину, или BFS (англ. breadth-first search, поиск в
        ширину). Его иногда также называют волновым, по аналогии с распространяющейся волной.

        <br><br>Суть BFS достаточно проста. Обход начинается с посещения определённой вершины (для обхода всего графа
        часто выбирается произвольная вершина). Затем алгоритм посещает соседей этой вершины. За ними - соседей соседей,
        и так далее.

        <br><br>Более формально, пусть d[i] - расстояние от начальной вершины до вершины с номером i (длина кратчайшего
        пути в рёбрах). BFS посещает вершины в порядке возрастания d[i]: от наименее до наиболее отдалённых.
    <p style="font-size: 30px">Алгоритм</p>
    <p>
        Как можно увидеть из иллюстрации, сам алгоритм достаточно тривиален. Поддерживается очередь из вершин для
        посещения. При посещении очередной вершины в очередь добавляются все её соседи, которые ещё не были посещены и
        ещё не находятся в очереди. Для проверки, была ли вершина уже посещена, используется массив меток. Изначально
        visited[i]=false для всех i кроме начальной вершины. При добавлении вершины i в очередь visited[i] присваивается
        true.
    <p style="font-size: 30px">Реализация</p>
    <p>
        Реализуем простой BFS для графа заданного списком смежности:
    <div class="code-box">
            <pre>
<b>1.</b> using namespace std;
<b>2.</b>
<b>3.</b> vector&lt;int> graph[100000];
<b>4.</b> bool used[100000];      //вместо visited массив меток обычно называют used.
<b>5.</b>
<b>6.</b> int main() {
<b>7.</b>     //Ввод графа...
<b>8.</b>
<b>9.</b>     queue&lt;int> q;
<b>10.</b>    q.push(0);              //в качестве начальной вершины используем 0.
<b>11.</b>    used[0] = true;
<b>12.</b>
<b>13.</b>    while (!q.empty()) {
<b>14.</b>        int cur = q.front();  //извлекаем из очереди текущую вершину
<b>15.</b>        q.pop();
<b>16.</b>
<b>17.</b>        //Здесь должна быть обработка текущей вершины.
<b>18.</b>        cout << "BFS at vertex " << cur + 1 << endl;
<b>19.</b>
<b>20.</b>        for (int neighbor: graph[cur]) {    //добавляем всех непосещённых соседей.
<b>21.</b>            if (!used[neighbor]) {
<b>22.</b>                q.push(neighbor);
<b>23.</b>                used[neighbor] = true;
<b>24.</b>            }
<b>25.</b>        }
<b>26.</b>    }
<b>27.</b>}
            </pre>
    </div>
    <p style="font-size: 30px">Практическое применение: вычисление расстояния до всех вершин</p>
    <p>
        BFS по определению посещает вершины в порядке возрастания расстояния от них до начальной. Поэтому одним из
        главных его применений является вычисление расстояния от заданной вершины до всех остальных.

        <br><br>Модификация алгоритма, необходимая для этого, минимальна. Пусть при обработке вершины i мы добавляем в
        очередь вершину j. Это значит, что кратчайший путь от начальной вершины до вершины j проходит через вершину i.

        <br><br><span style="background: rgba(133,132,132,0.51)">Доказательство: допустим, что существует более короткий путь в j, не проходящий через i. Обозначим предпоследнюю вершину этого пути k. Так как путь в j через k короче пути в j через i можно сделать вывод, что расстояние до k меньше расстояния до i. Но по определению BFS вершина k в таком случае была бы уже обработана, а значит, j бы уже находилась в очереди. Получили противоречие. Следовательно, подходящей вершины k не существует.</span>

        <br><br>Обозначим расстояние от начальной вершины до вершины i как dst[i]. В таком случае верно, что
        dst[j]=dst[i]+1. Таким образом мы можем рассчитать растояние для всех вершин.

        <br><br>Реализация:
    <div class="code-box">
            <pre>
<b>1.</b> using namespace std;
<b>2.</b>
<b>3.</b> vector&lt;int> graph[100000];
<b>4.</b> bool used[100000];
<b>5.</b> int dst[100000];
<b>6.</b>
<b>7.</b> int main() {
<b>8.</b>     //Ввод графа...
<b>9.</b>
<b>10.</b>    for (int i = 0; i < 100000; i++) {   //изначально заполним массив dst значением -1
<b>11.</b>        dst[i] = -1;                     //оно будет обозначать, что расстояние до этой вершины ещё неизвестно
<b>12.</b>    }
<b>13.</b>
<b>14.</b>    queue&lt;int> q;
<b>15.</b>    q.push(0);
<b>16.</b>    used[0] = true;
<b>17.</b>    dst[0] = 0;         //теперь при добавлении каждой вершины в очередь мы вычисляем расстояние до неё
<b>18.</b>
<b>19.</b>    while (!q.empty()) {
<b>20.</b>        int cur = q.front();
<b>21.</b>        q.pop();
<b>22.</b>
<b>23.</b>        for (int neighbor: graph[cur]) {
<b>24.</b>            if (!used[neighbor]) {
<b>25.</b>                q.push(neighbor);
<b>26.</b>                used[neighbor] = true;
<b>27.</b>                dst[neighbor] = dst[cur] + 1;   //вот и весь код расчёта расстояния
<b>28.</b>            }
<b>29.</b>        }
<b>30.</b>    }
<b>31.</b>
<b>32.</b>    for (int i = 0; i < n; i++) {
<b>33.</b>        if (dst[i] != -1) {
<b>34.</b>            cout << "Distance between vertices 1 and " << i + 1 << " is " << dst[i] << endl;
<b>35.</b>        } else {
<b>36.</b>            cout << "Vertex " << i + 1 << " cannot be reached from vertex 1." << endl;
<b>37.</b>        }
<b>38.</b>    }
<b>39.</b>}
            </pre>
    </div>
    <p>
        Стоит заметить одно важное свойство. Если существуют вершины, в которые невозможно добраться из 1-й вершины,
        dst[i] для них будет равно −1. Можно вспомнить об определении связности графа. Если после окончания работы
        алгоритма в массиве dst осталось хоть одно значение −1, то граф не является связным. Таким образом BFS можно
        также использовать для проверки на связность.
    <p style="font-size: 30px">BFS с сохранением пути</p>
    <p>
        Иногда кроме длины кратчайшего пути в задаче требуется также вывести вершины, через которые он проходит. BFS
        легко модифицируется для решения этой задачи.

        <br><br>Пусть при обработке вершины i мы добавляем в очередь вершину j. Это значит, что кратчайший путь от
        начальной вершины до вершины j проходит через вершину i (доказательство выше). Значит последним ребром в
        кратчайшем пути до j будет ребро i−j, а весь остальной путь будет совпадать с кратчайшим путём до i. Просто
        сохраним тот факт, что предыдущей вершиной для j является i. Для этого будем использовать массив prev. Простой
        пометки prev[j]=i хватит для восстановления пути после завершения работы алгоритма.

        <br><br>Реализация:
    </p>
    <div class="code-box">
                <pre>
<b>1.</b>using namespace std;
<b>2.</b>
<b>3.</b>vector&lt;int> graph[100000];
<b>4.</b>bool used[100000];
<b>5.</b>int dst[100000];
<b>6.</b>int pr[100000];   //имя prev уже используется библиотекой, поэтому назовём массив pr
<b>7.</b>
<b>8.</b>int main() {
<b>9.</b>    //Ввод графа...
<b>10.</b>
<b>11.</b>    for (int i = 0; i < 100000; i++) {
<b>12.</b>        dst[i] = -1;
<b>13.</b>    }
<b>14.</b>
<b>15.</b>    queue&lt;int> q;
<b>16.</b>    q.push(0);
<b>17.</b>    used[0] = true;
<b>18.</b>    dst[0] = 0;
<b>19.</b>    pr[0] = -1;   //Пометка, означающая, что у вершины 0 нет предыдущей.
<b>20.</b>
<b>21.</b>    while (!q.empty()) {
<b>22.</b>        int cur = q.front();
<b>23.</b>        q.pop();
<b>24.</b>
<b>25.</b>        for (int neighbor: graph[cur]) {
<b>26.</b>            if (!used[neighbor]) {
<b>27.</b>                q.push(neighbor);
<b>28.</b>                used[neighbor] = true;
<b>29.</b>                dst[neighbor] = dst[cur] + 1;
<b>30.</b>                pr[neighbor] = cur;   //сохранение предыдущей вершины
<b>31.</b>            }
<b>32.</b>        }
<b>33.</b>    }
<b>34.</b>
<b>35.</b>    //Восстановим кратчайший путь до вершины k (которую, предполагается, мы уже ввели)
<b>36.</b>    //Для восстановления пути пройдём его в обратном порядке, начиная с j, и развернём.
<b>37.</b>
<b>38.</b>    vector&lt;int> path;
<b>39.</b>
<b>40.</b>    int cur = k;         //текущая вершина пути
<b>41.</b>    path.push_back(cur);
<b>42.</b>
<b>43.</b>    while (pr[cur] != -1) {   //пока существует предыдущая вершина
<b>44.</b>        cur = pr[cur];        //переходим в неё
<b>45.</b>        path.push_back(cur);    //и дописываем к пути
<b>46.</b>    }
<b>47.</b>
<b>48.</b>    reverse(path.begin(), path.end());
<b>49.</b>
<b>50.</b>    cout << "Shortest path between vertices 1 and " << k + 1 << " is: " << endl;
<b>51.</b>
<b>52.</b>    for (int v: path) {
<b>53.</b>        cout << v + 1 << ", ";
<b>54.</b>    }
<b>55.</b>}
                </pre>
    </div>

</div>

<div class="site-footer">
    <a href="https://t.me/high_faev" class="double-border-button">My Telegram</a>
    <p class="glow-effect-mini">
        <span><span>В</span><span>о</span><span>о</span><span>б</span><span>р</span><span>а</span><span>ж</span><span>а</span><span>е</span><span>м</span><span>о</span><span>е</span></span>
        <span><span>б</span><span>о</span><span>г</span><span>а</span><span>т</span><span>с</span><span>т</span><span>в</span><span>о</span></span>
        <span><span>з</span><span>н</span><span>а</span><span>н</span><span>и</span><span>я</span></span>
        <span>—</span>
        <span><span>г</span><span>л</span><span>а</span><span>в</span><span>н</span><span>а</span><span>я</span></span>
        <span><span>п</span><span>р</span><span>и</span><span>ч</span><span>и</span><span>н</span><span>а</span></span>
        <span><span>е</span><span>г</span><span>о</span></span>
        <span><span>б</span><span>е</span><span>д</span><span>н</span><span>о</span><span>с</span><span>т</span><span>и</span></span>
    </p>
</div>
<script src="../jscode.js"></script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>